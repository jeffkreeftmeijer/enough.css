#+title: enough.css
#+html_doctype: html5
#+options: toc:nil num:nil html-style:nil html-postamble:nil
#+html_head: <link rel="stylesheet" href="enough.sans.css"/>
#+macro: bytes-sans (eval (file-attribute-size (file-attributes "enough.sans.min.css")))
#+macro: bytes-serif (eval (file-attribute-size (file-attributes "enough.serif.min.css")))

enough.css is a tiny (*{{{bytes-sans}}}--{{{bytes-serif}}} bytes!*) CSS framework with most of the styling you need for that blog of yours.
It's an attempt to embrace the browser's default style sheets while adding some minor changes to aid readability and responsiveness.

[[https://jeffkreeftmeijer.github.io/enough.css/][file:./screenshot.png]]

#+TOC: headlines

* Features

** Font

Most, if not all, browsers default to /Times New Roman/ as the typeface, with a font size of 16 pixels and a line height of 125 %.
Enough.css produces larger, responsive text in one of two modern typefaces, with more spacing between lines.

The first style, called =enough.sans.css= uses a sans-serif font.
Its preferred font family is /system-ui/, which points to the operating system's default font.
This produces text in Apple's /San Fransisco/ font on macOS and iOS, and falls back to a sans-serif font on other platforms:

#+name: sans
#+begin_src css
  html{
    font: clamp(16px, 2.2vw, 22px)/1.5 system-ui, sans-serif;
  }
#+end_src

The second, called =enough.serif.css= uses a serif.
Here, chosen font is /ui-serif/, which uses the operating system's default serif font.
On macOS and iOS, that's Apple's /New York/, with a fallback to /Palatino/, or the default serif font:

#+name: serif
#+begin_src css
  html{
    font: clamp(16px, 2.2vw, 22px)/1.5 ui-serif, New York, Palatino, serif;
  }
#+end_src

Smaller font sizes are great for 14â€³ monitors with low resolutions, but produce text that's uncomfortable to read on modern displays.
Enough.css uses CSS's =clamp()= function to produce a font size that matches 2.2% of the viewport width with a 16-pixel minimum and a 22 pixel maximum.
In practice, this means a 16 pixel font size for phones, maximum screen usage on tablets and a responsive font size that's configurable by resizing the window on desktop.

Finally, the line height is 150 %, producing a 33 pixel line height for 22 pixel body text.

** Body width and padding

Enough.css adds a maximum width to pages to keep lines from running too long, with padding that ensures there's always some space between the text and the sides of the page, even if the window is resized:

#+name: body
#+begin_src css
  body{
    margin: auto;
    padding: 0 2em;
    max-width: 40em;
  }
#+end_src

A 40 em page width produces an 880-pixel wide page if for a 22 pixel font size, fitting around 85 characters per line.
A 2 em padding is added to the sides, which produces 44 pixels on each size for a 22 pixel font size, which are added to the page's width.

If the window is wider than 968 pixels, the side paddings increase to keep the body in the center of the window.
If the window is narrower, the body also becomes narrower.
The padding remains at 2 em, but reduces in size because of responsive font sizing.

** Image and video widths

To keep images and video tags from overflowing and producing horizontal scroll bars, enough.css caps their widths to 100 % of the body width:

#+name: img
#+begin_src css
  img, video{
    max-width: 100%;
    height: auto;
  }
#+end_src

Doing this automatically scales images and videos down to fit the page.
Setting an automatic height makes sure the images or videos keep their aspect ratio, even if they're resized.

** Code

Code, either in =<code>= tags, =<kbd>= tags, or =<pre>= blocks, uses a different typeface, a smaller font, and scroll bars when overflowing:

#+name: code
#+begin_src css
  code,kbd,pre{
    font: 0.85rem ui-monospace, SFMono-Regular, Monaco, monospace;
  }

  pre{
    overflow: auto;
  }
#+end_src

Enough.css switches code elements to the /ui-monospace/ font family, which is Apple's /SF Mono/ font in Safari on macOS and iOS.
For other browsers, /SFMono-Regular/ (works on Chrome on macOS) and /Monaco/ are tried before falling back to the default monospace font.

The font size is reduced to 0.85 /rem/.
The rem unit is used instead of em because it's relative to the font size set for the main =html= tag instead of the containing element.
This makes sure the font size for code is always 85 % of the size for body text, even if a code block is nested in a =<pre>= tag.

The font size for code is smaller to make it fit better in the flow of body text, but also to have enough room for code blocks within the width of the page body.
The 0.85 rem size gives enough space for roughly 74 characters on bigger screens, and 36 characters on 375-pixel wide phones.

If a code block doesn't fit the page body, a scroll bar is displayed instead of overflowing.

** Tables

Tables take the full width of the page and have collapsed borders around each cell.
Each cell also has a slight padding to give the data some breathing room:

#+name: table
#+begin_src css
  table{
    border-collapse: collapse;
    width: 100%;
  }
  
  td, th{
    padding: 0.5em;
    border: 1px solid;
  }
#+end_src

By default, the width of tables is based on their contents.
Enough.css stretches tables to have them fill the page width.

Each table cell has a 1-pixel solid border, without a set color.
Omitting the color reuses the body text color, which is black by default.
The /border-collapse/ property is used to combine the borders of adjacent cells.

* Overview                                                         :noexport:

#+headers: :tangle enough.sans.css
#+headers: :noweb yes
#+begin_src css
  <<sans>>

  <<body>>

  <<img>>

  <<code>>

  <<table>>
#+end_src

#+headers: :tangle enough.serif.css
#+headers: :noweb yes
#+begin_src css
  <<serif>>

  <<body>>

  <<img>>

  <<code>>

  <<table>>
#+end_src

* Contributing

** Minification

#+headers: :exports none
#+headers: :tangle postcss.config.js
#+begin_src js
module.exports = {
  plugins: [
    require('cssnano')({
      preset: 'default',
    }),
  ],
};
#+end_src

A minified version of enough.sans.css is bundled in /enough.sans.min.css/
It's generated by passing the source file through [[https://postcss.org][PostCSS]], which is configured to use [[https://cssnano.co][cssnano]].
Use NPM's install command to install the dependencies:

#+begin_src shell
  npm install
#+end_src

Then, minify enough.sans.css through npx:

#+name: minify
#+begin_src shell :prologue npm install > /dev/null
  npx postcss enough.sans.css > enough.sans.min.css
  npx postcss enough.serif.css > enough.serif.min.css
#+end_src

** Git pre-commit hook

The minified version of enough.sans.css should always be kept up to date.
As a convenience, it's recommended to set up the minification command as a git pre commit hook.
A script for this is prepared in [[file:scripts/pre-commit][=scripts/pre-commit=]].
To enable it as a pre-commit hook, symlink to it from git's hooks directory:

#+headers: :exports none
#+headers: :shebang #/bin/sh
#+headers: :noweb yes
#+headers: :tangle scripts/pre-commit
#+begin_src shell
  <<minify>>
#+end_src

#+headers: :prologue rm .git/hooks/pre-commit
#+begin_src shell
  (cd .git/hooks && ln -s ../../scripts/pre-commit)
#+end_src

With the pre-commit hook set up, the minification command will be automatically run before changes are committed.
To commit a change without running the hook, use the =--no-verify= flag.

** Generating the Markdown README

This project uses [[https://github.com/jeffkreeftmeijer/readme.el][readme.el]] to export the main Org file to a Markdown README for compatibility with GitHub, to show on the repository's public page:

#+name: generate-readme
#+begin_src shell
  emacs --batch enough.css.org --load scripts/readme.el/readme.el --eval "(readme/to-markdown \"README.md\")"
#+end_src

A GitHub workflow regenerates the Markdown whenever the main or develop branch receive changes.
Therefor, local changes to the Markdown file shouldn't be pushed to the remote repository.

#+headers: :exports none
#+headers: :noweb yes
#+headers: :tangle .github/workflows/readme.yml
#+begin_src yaml
name: README

on:
  push:
    branches: [ "main", "develop" ]

jobs:
  generate:
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v3
        with:
          submodules: recursive
          fetch-depth: 0
      - uses: purcell/setup-emacs@master
        with:
          version: 28.2
      - run: <<generate-readme>>
      - uses: stefanzweifel/git-auto-commit-action@v4
        with:
          commit_message: Regenerate README.md
#+end_src
